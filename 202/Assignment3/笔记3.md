



vscodeè£…ä¸ªlive serverï¼Œæ¯”åŸå…ˆé‚£ä¸ªhttp-serverå¥½ç”¨å¤šäº†ï¼Œå†ä¹Ÿä¸ç”¨è´¹åŠ²å·´æ‹‰åœ°åˆ·æ–°äº†ï¼Œçœ‹webgléƒ½çœ‰æ¸…ç›®ç§€äº†å‡ åˆ†ã€‚ä¸ä¼šå†™å°±åå¤æ¨ªè·³ï¼Œä¸€ä¸‹å°±è·³åˆ°ä½œä¸šä¸‰ï¼Œä¸æ„§æ˜¯æˆ‘ï¼ˆå‰è…°

ç¬¬ä¸€æ­¥ï¼Œåœ¨å»¶è¿Ÿæ¸²æŸ“çš„æ¡†æ¶ä¸‹ï¼Œæ ¹æ®gbufferé‡Œå·²æœ‰çš„æ·±åº¦ã€ä¸–ç•Œç©ºé—´æ³•çº¿ã€ä¸–ç•Œåæ ‡å’Œalbedoä¿¡æ¯ï¼Œè®¡ç®—ç›´æ¥å…‰æºè´¡çŒ®çš„æ¼«åå°„å…‰ç…§ã€‚

* woä¼¼ä¹æ²¡ç”¨

  ```glsl
  vec3 EvalDiffuse(vec3 wi, vec3 wo, vec2 uv) {
    vec3 N = normalize(GetGBufferNormalWorld(uv));
    vec3 albedo = GetGBufferDiffuse(uv);
    vec3 L = albedo * max(0.0, dot(N, wi)) * INV_PI;
    return L;
  }
  ```

ç¬¬äºŒæ­¥ï¼Œç”¨ray marchçš„æ–¹æ³•ç®€å•åœ°å®ç°ssrï¼Œä¸ºäº†æ–¹ä¾¿debugï¼Œå…ˆç”¨è§†çº¿çš„åå°„å‘é‡é‡‡æ ·ï¼Œå®ç°ä¸€ä¸ªç±»ä¼¼é•œé¢åå°„ã€‚

ä¸€äº›å®ç°ä¸Šçš„ç»†èŠ‚ï¼ˆå‘ï¼‰ï¼š 

* ç©ºé—´å’Œæ·±åº¦å€¼ï¼šä¸–ç•Œç©ºé—´+é€šè¿‡æ¯”è¾ƒçº¿æ€§æ·±åº¦å€¼æ¥åˆ¤æ–­æ˜¯å¦ç›¸äº¤

* é‡‡æ ·æ­¥é•¿å’Œæ•°é‡ï¼šå¦‚æœæ­¥è¿›åœ¨ç›¸æœºç©ºé—´ï¼Œåˆ™å¯ä»¥é€šè¿‡ç›¸æœº(far plane - near plane)/samples å¾—åˆ°æ­¥é•¿,  æ­¥é•¿æ•°é‡ç›´æ¥å½±å“ç”»è´¨ï¼Œå®šæ­¥é•¿ä¼šå¸¦æ¥æ˜æ˜¾çš„æ¡å¸¦çŠ¶èµ°æ ·ï¼ŒæŠ–åŠ¨ä¼˜åŒ–ä¼šå¸¦æ¥å™ªéŸ³ã€‚

* ~~è€ƒè™‘å¤©ç©ºç›’ï¼Ÿ~~

* ä¹ æƒ¯ä¸Šä¸ºäº†æ–¹ä¾¿è®¡ç®—ï¼Œæ‰€è°“â€œè§†çº¿â€æ˜¯ä»ä¸–ç•Œåæ ‡æŒ‡å‘ç›¸æœºä½ç½®ï¼Œå’Œè¯­ä¹‰ç›¸åï¼Œå®é™…æ±‚åå°„å‘é‡è¦è®°å¾—å–åğŸ˜…ã€‚

  ```glsl
    vec3 V = normalize(uCameraPos - posWorld);
    vec3 R = normalize(reflect(-V, N));
  ```

* å‡ºç°ç±»ä¼¼z-fightingçš„å™ªéŸ³ï¼Œæ³¨æ„æµ®ç‚¹æ•°ç²¾åº¦ã€‚

  ```glsl
   if(z - depth > 1e-3){// hit 1e-6
   //if(z > depth){// wrong
  ```

* è§‚å¯Ÿåˆ°zoom inæ—¶åå°„å¹³é¢è¾¹ç¼˜å‡ºç°å¥‡æ€ªçš„ç±»ä¼¼clampçš„ç°è±¡ï¼Œzoom outæ¶ˆå¤±ï¼Œè¿™æ˜¯å› ä¸ºå°„çº¿æ­¥è¿›åˆ°å±å¹•ä¹‹å¤–ï¼Œæ— æ³•ä»gbufferé‡Œè·å¾—æœ‰æ•ˆä¿¡æ¯ï¼Œæ‰€ä»¥éœ€è¦åˆ¤æ–­å±å¹•åæ ‡åœ¨èŒƒå›´ä¹‹å†…æˆ–è€…æ”¹å˜çº¹ç†ç¯ç»•æ–¹å¼ï¼Œè¿™ä¹Ÿæ˜¯å±å¹•ç©ºé—´ç³»ç®—æ³•æ— æ³•å›é¿çš„é—®é¢˜ã€‚

  ```glsl
  vec2 uv = GetScreenCoordinate(pos);
  if(uv.x < 0.0 || uv.y < 0.0)  return false;
  ```

  è€Œåœ¨è§†çº¿è¾ƒä½æ—¶ï¼Œå¹³é¢ä¸Šå‡ºç°ä¸è¯¥æœ‰çš„åå°„ï¼ŒçŒœæµ‹è·Ÿçº¹ç†åˆ†è¾¨ç‡æœ‰å…³ï¼Œkdè¾ƒå°æ—¶ç›´æ¥clamp

  <img src="imgs\step2.png" style="zoom: 33%;" />

* mipmapä¼˜åŒ–

ç¬¬ä¸‰æ­¥ï¼Œæ ¹æ®ä¼ªä»£ç ï¼Œç”¨ssrå®ç°é—´æ¥å…‰æ¼«åå°„ã€‚æ¼«åå°„åœ¨åŠçƒå†…éšæœºé‡‡æ ·ï¼Œé•œé¢åå°„éœ€è¦æ ¹æ®lobeé‡è¦æ€§é‡‡æ ·ã€‚

<img src="imgs\pseudocode.png"  />

* çƒé¢ä¸Šç”Ÿæˆçš„é‡‡æ ·å‘é‡åœ¨åˆ‡çº¿ç©ºé—´å†…ï¼Œéœ€è¦è½¬æ¢åˆ°ä¸–ç•Œç©ºé—´å†…ã€‚

  ```glsl
  vec3 tanToWorld(vec3 worldN, vec3 tanV){
    vec3 T, B;
    LocalBasis(worldN, T, B);
    mat3 TBN = mat3(normalize(T), normalize(B), worldN);
    return normalize(TBN * tanV);
  }
  ```

* éšæœºæ•°ä½¿ç”¨ï¼Ÿ

  ```glsl
      //float seed = float(i); æ¯ä¸ªé‡‡æ ·ç‚¹ç”Ÿæˆä¸€ä¸ªseed,ä¸ä¼šæœ‰å™ªéŸ³
      //float r = Rand1(seed);
  	Rand1(s);
  ```

* pdfé‡‡æ ·æ¦‚ç‡ï¼Œä¸ºå•¥æ¯ä¸€é¡¹éƒ½è¦ä¹˜po/pdf

  ```glsl
        L += EvalDiffuse(dir, vec3(0.), uv0) / pdfs[i] * EvalDiffuse(uLightDir, vec3(0.), uv) * EvalDirectionalLight(uv);
  
  ```

  

* å…‰æºå¯¹äº¤ç‚¹çš„è´¡çŒ®ï¼Œç­‰äºäº¤ç‚¹çš„è¾ç…§åº¦ï¼Œå³äº¤ç‚¹ä½œä¸ºé—´æ¥å…‰æºå½±å“render point

* ä¸éœ€è¦è€ƒè™‘å…‰çº¿åœ¨ä¼ æ’­è¿‡ç¨‹ä¸­çš„è¡°å‡å’Œå¯è§æ€§ï¼Ÿ

* ~~å‡ºç°äº†ç±»ä¼¼SSAOã€è¿œè·ç¦»å¤„å‡ºç°ä¸è¯¥å‡ºç°çš„é—´æ¥å…‰~~

* é»‘è¾¹

  <center><img src="imgs\step1.png" style="zoom:33%;" /><img src="imgs\step3.png" style="zoom:33%;" /></center>





ğŸ¦„

glsl https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.30.pdf#page=35

https://advances.realtimerendering.com/s2015/index.html