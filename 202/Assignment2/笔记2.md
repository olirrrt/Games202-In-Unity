# hmw2


$$
L(w_o) = \int_{\Omega}L(w_i)V(w_i)\rho(w_i,w_o) max(0, nÂ·w_i)dw_i
$$
$V(w_i)$ æ˜¯shading pointçš„å¯è§æ€§ï¼›$\rho(w_i,w_o) $æ˜¯BRDFé¡¹ï¼Œå› ä¸ºåªè€ƒè™‘æ¼«åå°„ï¼Œæ‰€ä»¥å¯ä»¥æå–ä¸ºå¸¸æ•°é¡¹$c/\pi$ã€‚

ä¼ è¾“é¡¹å‡½æ•°çš„è¡¨è¾¾å¼ä¸ºï¼š
$$
T_i = V(w_i)max(0, nÂ·w_i)
$$
ç¯å¢ƒå…‰ç…§å‡½æ•°$L(w_i)$ï¼Œæ²¡æœ‰å¯¹åº”çš„æ•°å­¦è¡¨è¾¾å¼ï¼Œå…¶è¾“å…¥é‡‡æ ·å‘é‡ï¼Œé‡‡æ ·ç¯å¢ƒå…‰è´´å›¾ä½œä¸ºè¿”å›å€¼ã€‚

$L(w_i)$é¡¹ä½ç½®æ— å…³ï¼Ÿ

éœ€è¦åšçš„æ˜¯å°†è¿™ä¸¤ä¸ªå‡½æ•°åˆ†åˆ«æŠ•å½±åˆ°çƒè°å‡½æ•°ä¸Šï¼Œæ±‚å‡ºå¯¹åº”ç³»æ•°å¹¶å­˜å‚¨åˆ°çŸ©é˜µé‡Œï¼Œåœ¨æ¸²æŸ“æ—¶ä½¿ç”¨ï¼ŒåŒ–ç§¯åˆ†ä¸ºç‚¹ä¹˜ã€‚
$$
L_? = \sum_{i=0}^{n} L_i T_i
$$

* m_LightCoeffs ï¼šè®°å½•ç¯å¢ƒå…‰çš„çƒè°ç³»æ•°ï¼Œä»¥rgbçš„å½¢å¼å­˜å‚¨ï¼Œæ˜¯å¤§å° 3 x (l+1)^2çš„çŸ©é˜µï¼Œæ¯åˆ—å­˜å‚¨æ¯ä¸ªç¯å¢ƒå…‰ç³»æ•°çš„rgbå€¼ï¼›

* m_TransportSHCoeffsï¼š è®°å½•ä¼ è¾“é¡¹ç³»æ•°ï¼Œæ˜¯å¤§å°(l+1)^2 x é¡¶ç‚¹æ•°é‡çš„çŸ©é˜µï¼Œ(i , j) å­˜å‚¨ç¬¬jä¸ªé¡¶ç‚¹çš„ç¬¬iä¸ªç³»æ•°ã€‚



## Project :

### è®¡ç®—ç¯å¢ƒå…‰ç³»æ•°

ç¬¬ä¸€æ­¥éœ€è¦åœ¨PrecomputeCubemapSHå‡½æ•°å®Œæˆå¯¹ç¯å¢ƒå…‰ç³»æ•°çš„æ±‚è§£ã€‚

```c++
auto envCoeffs = ProjEnv::PrecomputeCubemapSH<SHOrder>(images, width, height, channel);
```

EvalSH å‡½æ•°å³ $Y_{lm}(\theta, \varphi)$ , è®¡ç®—æ¯ä¸ªå•ä½æ–¹å‘å‘é‡å¯¹åº”çš„åŸºå‡½æ•°å€¼

 ```c++
 double EvalSH(int l, int m, const Eigen::Vector3d& dir) 
 ```

å¯¹äºcubemap6ä¸ªé¢çš„æ¯ä¸€ä¸ªçº¹ç´ ï¼Œè®¡ç®—å…¶å¯¹æ¯ä¸€ä¸ªç³»æ•°çš„è´¡çŒ®ã€‚å…¶ä¸­ç¬¬lé˜¶ç¬¬mä¸ªç³»æ•°å¯¹åº”æ•°ç»„åºå·å¯å‚è€ƒæºç é‡Œçš„GetIndexå‡½æ•°ã€‚

```c++
constexpr int GetIndex(int l, int m) {
  return l * (l + 1) + m;
}
```

ï¼Ÿ CalcAreaç«‹ä½“è§’

```c++
	for (int i = 0; i < 6; i++)
	{
		for (int y = 0; y < height; y++)// éå†æ¯ä¸ªçº¹ç´ 
		{
			for (int x = 0; x < width; x++)
			{
				// TODO: here you need to compute light sh of each face of cubemap of each pixel
				// TODO: æ­¤å¤„ä½ éœ€è¦è®¡ç®—æ¯ä¸ªåƒç´ ä¸‹cubemapæŸä¸ªé¢çš„çƒè°ç³»æ•°
				Eigen::Vector3f dir = cubemapDirs[i * width * height + y * width + x];// å½’ä¸€åŒ–çš„å•ä½å‘é‡
				int index = (y * width + x) * channel;
				Eigen::Array3f Le(images[i][index + 0], images[i][index + 1],
					images[i][index + 2]);

				for (int l = 0; l < SHOrder; l++) {
					for (int m = -l; m <= l; m++) {
						float sh = sh::EvalSH(l, m, dir.cast<double>().normalized());
						float delta = CalcArea(x, y, width, height);
						SHCoeffiecents[l * (l + 1) + m] += Le * sh * delta;// é»æ›¼å’Œæ±‚ç§¯åˆ†
					}
				}
			}
		}
	}
```

### è®¡ç®—ä¼ è¾“é¡¹ç³»æ•°

shFunc æ˜¯ä¼ è¾“é¡¹å‡½æ•°ï¼Œæ˜¯éœ€è¦è¢«æŠ•å½±åˆ°çƒè°å‡½æ•°ä¸Šçš„æ–¹ç¨‹ã€‚

```c++
auto shCoeff = sh::ProjectFunction(SHOrder, shFunc, m_SampleCount);
for (int j = 0; j < shCoeff->size(); j++){
  	m_TransportSHCoeffs.col(i).coeffRef(j) = (*shCoeff)[j];
}
```

```c++
// Fit the given analytical spherical function to the SH basis functions
// up to @order. This uses Monte Carlo sampling to estimate the underlying
// integral.
std::unique_ptr<std::vector<double>> ProjectFunction(
    int order, const SphericalFunction& func, int sample_count);
```

unshadowedå’Œshadowedæ²¡å•¥å¥½è¯´ï¼Œç¿»è¯‘å…¬å¼å¡«åˆ°shFuncé‡Œå°±è¡Œï¼›

```c++
				if (m_Type == Type::Unshadowed)
				{
					// TODO: here you need to calculate unshadowed transport term of a given direction
					// TODO: æ­¤å¤„ä½ éœ€è¦è®¡ç®—ç»™å®šæ–¹å‘ä¸‹çš„unshadowedä¼ è¾“é¡¹çƒè°å‡½æ•°å€¼
					return std::max(float(0.), wi.dot(n));
				}
				else
				{
					// TODO: here you need to calculate shadowed transport term of a given direction
					// TODO: æ­¤å¤„ä½ éœ€è¦è®¡ç®—ç»™å®šæ–¹å‘ä¸‹çš„shadowedä¼ è¾“é¡¹çƒè°å‡½æ•°å€¼
					double H = wi.dot(n);
					return (H > 0 && !(scene->rayIntersect(Ray3f(v, wi.normalized()))))? H : 0;
				}
```

è€Œå¯¹äºinterrelectionçš„æƒ…å†µï¼Œæ–‡æ¡£é‡Œç»™å‡ºçš„æ­¥éª¤å¦‚ä¸‹ï¼š

<img src="imgs/ä¼ª.png" alt="ä¼ª" style="zoom:100%;" />

> it recursively adds in light not arriving directly from a light source, but as secondary reflected light from other polygons visible to a point on the model.

> Linearly interpolate the SH functions at each corner of the triangle using the barycentric coordinates of the hit. 

<center ><img src="imgs/shadowed.png" alt="prt" style="zoom:33%;" /> <img src="imgs/interreflection.png" alt="prt" style="zoom:33%;" /><p style="color:#A9A9A9;">
  å·¦shadowedï¼Œå³interreflection = 2
  </p></center>

### æ—‹è½¬



## Reconstruct

ç›´æ¥ç¿»è¯‘å…¬å¼3ï¼Œåœ¨vertex shaderé‡Œè®¡ç®—é¢œè‰²ï¼Œç»æ’å€¼åä¼ é€’ç»™fragment shaderå³å¯ã€‚

```glsl
attribute mat3 aPrecomputeLT;

uniform mat3 uPrecomputeLR;
uniform mat3 uPrecomputeLG;
uniform mat3 uPrecomputeLB;

varying vec3 vColor;

void main(void) {
    vColor = vec3(0.0);
    for(int i = 0; i < 3; i++){
        for(int j = 0; j < 3; j++){
            vColor += aPrecomputeLT[i][j] * vec3(uPrecomputeLR[i][j], uPrecomputeLG[i][j], uPrecomputeLB[i][j]);
        }
    }
    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);
}
```



<center ><img src="imgs/prt-sh.png" alt="prt" style="zoom:25%;" /> <img src="imgs/prt-in.png" alt="prt" style="zoom:25%;" /><p style="color:#A9A9A9;">
  å·¦shadowedï¼Œå³interreflection self- shadowç¨äº®
  </p></center>







ğŸ¦„ï¸

[https://www.cse.chalmers.se/~uffe/xjobb/Readings/GlobalIllumination/Spherical%20Harmonic%20Lighting%20-%20the%20gritty%20details.pdf](https://www.cse.chalmers.se/~uffe/xjobb/Readings/GlobalIllumination/Spherical Harmonic Lighting - the gritty details.pdf)
