## zzz

​		m_LightCoeffs 记录环境光的球谐系数，以rgb的形式存储，是大小 3 x (l+1)^2的矩阵，每列存储每个环境光系数的rgb值；

​		m_TransportSHCoeffs 记录传输项系数，是大小(l+1)^2 x 顶点数量的矩阵，(i , j) 存储第j个顶点的第i个系数。

```c++
Eigen::MatrixXf m_TransportSHCoeffs;

Eigen::MatrixXf m_LightCoeffs;
```

### 求环境光系数

​		预计算过程在preprocess函数内，其中第一步m_LightCoeffs的初始化，需要完成PrecomputeCubemapSH函数。

```c++
auto envCoeffs = ProjEnv::PrecomputeCubemapSH<SHOrder>(images, width, height, channel);

m_LightCoeffs.resize(3, SHCoeffLength);

for (int i = 0; i < envCoeffs.size(); i++)
{
    lightFout << (envCoeffs)[i].x() << " " << (envCoeffs)[i].y() << " " << (envCoeffs)[i].z() << std::endl;

    m_LightCoeffs.col(i) = (envCoeffs)[i];
}
```

​		需要分别求出cubemap6个面每个像素的球谐系数，

```c++
	for (int i = 0; i < 6; i++)
	{
		for (int y = 0; y < height; y++)// 遍历每个纹素
		{
			for (int x = 0; x < width; x++)
			{
				// TODO: here you need to compute light sh of each face of cubemap of each pixel
				// TODO: 此处你需要计算每个像素下cubemap某个面的球谐系数
				Eigen::Vector3f dir = cubemapDirs[i * width * height + y * width + x];// 归一化的单位向量
				int index = (y * width + x) * channel;
				Eigen::Array3f Le(images[i][index + 0], images[i][index + 1],
					images[i][index + 2]);

				for (int l = 0; l < SHOrder; l++) {
					for (int m = -l; m <= l; m++) {
						float sh = sh::EvalSH(l, m, dir.cast<double>().normalized());
						float delta = CalcArea(x, y, width, height);
						SHCoeffiecents[l * (l + 1) + m] += Le * sh * delta;// 黎曼和求积分
					}
				}
			}
		}
	}
```

### 求传输项系数

​		求传输项系数，需要遍历每一个顶点，并求出每一个对应系数。漫反射传输项分为unshadowed, shadowed, interreflection三种情况。

```c++
		auto shFunc = [&](double phi, double theta) -> double {// 对于每个顶点、遍历半球上的每个方向
			Eigen::Array3d d = sh::ToVector(phi, theta);
			const auto wi = Vector3f(d.x(), d.y(), d.z());// 采样向量
			if (m_Type == Type::Unshadowed)
			{
				// TODO: here you need to calculate unshadowed transport term of a given direction
				// TODO: 此处你需要计算给定方向下的unshadowed传输项球谐函数值
				double H = wi.dot(n);
				return (H > 0) ? H : 0;
			}
			else // shadowed or interreflection
			{
				// TODO: here you need to calculate shadowed transport term of a given direction
				// TODO: 此处你需要计算给定方向下的shadowed传输项球谐函数值
				double H = wi.dot(n);
				if (H > 0) {
					bool isVisable = !(scene->rayIntersect(Ray3f(v, wi.normalized())));// 从render point，沿采样向量
					return (isVisable) ? H : 0;
				}
				else
					return 0;
			}
		};
		auto shCoeff = sh::ProjectFunction(SHOrder, shFunc, m_SampleCount);
		for (int j = 0; j < shCoeff->size(); j++){
      	m_TransportSHCoeffs.col(i).coeffRef(j) = (*shCoeff)[j];
		}
```

其中sh::Project Function，\- Project an analytic spherical function into every basis function up to the specified order.给定阶数和采样数量，用蒙特卡罗积分法求出每一个基数的系数，总个数为order+1的平方。

```c++
std::unique_ptr<std::vector<double>> ProjectFunction(int order, const SphericalFunction& func, int sample_count);
```

```c++
std::unique_ptr<std::vector<double>> ProjectFunction(
    int order, const SphericalFunction& func, int sample_count) {
  CHECK(order >= 0, "Order must be at least zero.");
  CHECK(sample_count > 0, "Sample count must be at least one.");

  // This is the approach demonstrated in [1] and is useful for arbitrary
  // functions on the sphere that are represented analytically.
  const int sample_side = static_cast<int>(floor(sqrt(sample_count)));
  std::unique_ptr<std::vector<double>> coeffs(new std::vector<double>());
  coeffs->assign(GetCoefficientCount(order), 0.0);// （order + 1) * (order + 1)

  // generate sample_side^2 uniformly and stratified samples over the sphere
  std::random_device rd;
  std::mt19937 gen(rd());
  std::uniform_real_distribution<> rng(0.0, 1.0);
  for (int t = 0; t < sample_side; t++) {
    for (int p = 0; p < sample_side; p++) {
      double alpha = (t + rng(gen)) / sample_side;
      double beta = (p + rng(gen)) / sample_side;
      // See http://www.bogotobogo.com/Algorithms/uniform_distribution_sphere.php
      double phi = 2.0 * M_PI * beta;
      double theta = acos(2.0 * alpha - 1.0);

      // evaluate the analytic function for the current spherical coords
      double func_value = func(phi, theta);

      // evaluate the SH basis functions up to band O, scale them by the
      // function's value and accumulate them over all generated samples
      for (int l = 0; l <= order; l++) {
        for (int m = -l; m <= l; m++) {
          double sh = EvalSH(l, m, phi, theta);
          (*coeffs)[GetIndex(l, m)] += func_value * sh;
        }
      }
    }
  }

  // scale by the probability of a particular sample, which is
  // 4pi/sample_side^2. 4pi for the surface area of a unit sphere, and
  // 1/sample_side^2 for the number of samples drawn uniformly.
  double weight = 4.0 * M_PI / (sample_side * sample_side);
  for (unsigned int i = 0; i < coeffs->size(); i++) {
     (*coeffs)[i] *= weight;
  }

  return coeffs;
}
```

​		对于shadowed传输项，不可见的点即检测到被遮挡的点返回0；而需要考虑环境光在物体表面相互反射多次的情况，若有遮挡，则取射线交点处系数作为环境光系数，用三角形重心坐标和三个顶点系数的插值表示。多次反弹需要用迭代实现。

【每个顶点有(l+1)^2个系数】





### 旋转

